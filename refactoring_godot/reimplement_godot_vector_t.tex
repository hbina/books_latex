\documentclass[a4paper,10pt]{book}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{listings}
\usepackage{hyperref}

\title{Explaining Godot's Vector \textless T\textgreater }
\author{Hanif Bin Ariffin}

\begin{document}

\maketitle
\tableofcontents

\newpage
\section{Introduction}

This writing is part of my attempt to understand Godot's internal.
I hope it will help others as well.
As a side note, I am currently reading Game Engine Architecture.
I will try to make comments/criticism from what I have learned so far.
Thus, I do not claim to be an expert in the field, and criticism of this writing is greatly appreciated.

This short article is based on the commit hash:

\begin{lstlisting}
    3045697e4b808a8d5a440517dbb8f90a3f0f9a93
\end{lstlisting}

of the Godot source code's master branch available \href{https://github.com/godotengine/godot}{here} .

\section{The Copy On Write Principle}

Godot really likes the concept of having copy-on-write (COW) data.
This principle is, as far as I know, the core of most containers available in Godot's source code.\
The idea is that copying is unnecessary until a write operation is performed.

For instance, if we have :

\begin{lstlisting}[language=c++]
    Vector<int> vec1 = vec2;
\end{lstlisting}

It won't actually allocate any new data for \texttt{vec1}.
Instead, \texttt{vec1} points the same internal data of \texttt{vec2}.
As such, it does not need to copy the data over.
However, the user of this container surely hopes that writes to \texttt{vec1} wouldn't modify the \texttt{vec2}.
Thus, whenever a write operation is performed (resizing, clearing, adding, removing), the contents of \texttt{vec2} will be copied over.

\newpage
\section{Implementation of COW  \textless T\textgreater in Godot}

Here is the declarations of the methods of \texttt{COW<T>}

\begin{lstlisting}[language=c++]
    template <class T>
    class CowData {
    
    private:
        mutable T *_ptr;
        uint32_t *_get_refcount() const;
        uint32_t *_get_size() const;
        T *_get_data() const;
        size_t _get_alloc_size(size_t) const;
        bool _get_alloc_size_checked(size_t, size_t *) const;
        void _unref(void *);
        void _ref(const CowData *);
        void _ref(const CowData &);
        void _copy_on_write();
    public:
        void operator=(const CowData<T> &);
        T *ptrw();
        const T *ptr() const;
        int size() const;
        void clear();
        bool empty() const;
        void set(int, const T &);
        T &get_m(int);
        const T &get(int) const;
        Error resize(int);
        void remove(int);
        Error insert(int, const T &);
        int find(const T &, int p_from = 0) const;
        CowData();
        ~CowData();
        CowData(CowData<T> &);
    };
\end{lstlisting}

We will go through each of them.

\subsection{Constructor}

Let's begin with the constructor.
Here is the definition :

\begin{lstlisting}[language=c++]
template <class T>
CowData<T>::CowData() {
	_ptr = NULL;
}
\end{lstlisting}

Seems simple enough, but what exactly is \texttt{\_ptr} ?
It is simply a mutable pointer to an array of type T.
What does the \texttt{mutable} keyword do in C++?

The mutable permits modification of the class member declared mutable even if the containing object is declared const.

This is useful when you want to exclude a member variable from the \texttt{const} requirement of a member function.
However, this requirement is useless and I actually have no idea why its there lol.
I have inquired about this \href{https://github.com/godotengine/godot/issues/30706}{here}.

Regardless, where else \texttt{\_ptr} used ?
As it turns out, \texttt{\_ptr} is the most important member variable after all!
It is the pointer to the underlying C-array that we really care about.

Using raw-pointers are dangerous however.
As such, the class provides a helper method that wraps over this raw pointer.
The function is called given by the signature: \texttt{T * get\_data() const}.
Its implementation is given below :



So instead of accessing the \texttt{\_ptr} directly, this function is used in the code instead.

\end{document}
