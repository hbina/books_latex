\documentclass[a4paper,12pt]{book}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{listings}
\usepackage{hyperref}

\title{Explaining Godot's Vector \textless T\textgreater }
\author{Hanif Bin Ariffin}

\begin{document}

\maketitle
\tableofcontents

\newpage
\section{Introduction}

Godot does not use the standard template library anywhere.
This writing is part of my attempt to understand Godot, and maybe help others do the same.
I am currently reading Game Engine Architecture, as I am writing this article and I will try to make comments/criticism from what I have learned so far.
Thus, I do not claim to be an expert in the field, and criticism of this writing is greatly appreciated.

This short article is based on the commit hash:

\begin{lstlisting}
    3045697e4b808a8d5a440517dbb8f90a3f0f9a93
\end{lstlisting}

of the Godot source code's master branch available \href{https://github.com/godotengine/godot}{here} .

\newpage
\section{The Copy On Write Principle}

Godot really likes the concept of having copy-on-write (COW) data.
This principle is, as far as I know, the core of most containers available in Godot's source code.\
The idea is that copying is unnecessary until a write operation is performed.

For instance, if we have :

\begin{lstlisting}
    Vector<int> a = b;
\end{lstlisting}

It won't actually allocate any new data for \textit{a}.
Instead, \textit{a} points the same internal data of \textit{b}.
As such, it does not need to copy the data over.
However, the user of this container surely hopes that writes to \textit{a} wouldn't modify the \textit{b}.
Thus, whenever a write operation is performed (resizing, clearing, adding, removing), the contents of \textit{b} will be copied over.

\section{Implementation of COW  \textless T\textgreater in Godot}

Here is the declarations of the methods of COW  \textless T\textgreater.
\begin{lstlisting}
    template <class T>
    class CowData {
    
    private:
        mutable T *_ptr;
        uint32_t *_get_refcount() const;
        uint32_t *_get_size() const;
        T *_get_data() const;
        size_t _get_alloc_size(size_t) const;
        bool _get_alloc_size_checked(size_t, size_t *) const;
        void _unref(void *);
        void _ref(const CowData *);
        void _ref(const CowData &);
        void _copy_on_write();
    public:
        void operator=(const CowData<T> &);
        T *ptrw();
        const T *ptr() const;
        int size() const;
        void clear();
        bool empty() const;
        void set(int, const T &);
        T &get_m(int);
        const T &get(int) const;
        Error resize(int);
        void remove(int);
        Error insert(int, const T &);
        int find(const T &, int p_from = 0) const;
        CowData();
        ~CowData();
        CowData(CowData<T> &);
    };
\end{lstlisting}

We will go through each of them.

\subsection{Constructor}

We begin with the constructor.

\begin{lstlisting}
template <class T>
CowData<T>::CowData() {
	_ptr = NULL;
}
\end{lstlisting}

But what exactly is \_ptr ? It is simply a mutable pointer to an array of type T.
What does the \textit{mutable} keyword do in C++?
According to cppreference.com, the keyword \textit{mutable}

permits modification of the class member declared mutable even if the containing object is declared const. 

\end{document}
