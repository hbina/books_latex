\documentclass[a4paper,10pt]{book}
\usepackage[utf8]{inputenc}

\author{Hanif Bin Ariffin rewrites}
\title{Data Oriented Design}

\begin{document}

\maketitle
\tableofcontents

\newpage
\section{Data-Oriented Design}

Data-oriented design has been around for decades in one form or another but was only officially given a name by Noel Llopis in his September 2009 article [---link to article----] of the same name.
Whether it is, or not a programming paradigm is seen as contentious.
Many believe it can be used side by side with other programming paradigms such as object-oriented, procedural, or functional programming.
In one respect they are right, data-oriented design can function alongside the other paradigms, but that does not preclude it from being a way to approach programming in the large.
Other programming paradigms are known to function alongside each other to some extent as well.
A Lisp programmer knows that functional programming can coexist with objected-oriented programming and a C programmer is well aware that object-oriented programming can coexist with procedural programming.
We shall ignore these comments and claim data-oriented design as another important tool;
a tool just as capable of coexistence as the rest.

The time was right in 2009.
The hardware was ripe for a change in how to develop.
Potentially very fast computers were hindered by a hardware ignorant programming paradigm.
The way game programmers coded at the time made many engine programmers weep.
The time have changed.
Many mobile and desktop solutions now seem to need the data-oriented design approach less, not because the machines are better at mitigating an ineffective approach, but the games designed are less demanding and less complex.
The trend for mobile seems to be moving to AAA development, which should bring the return of a need for managing complexity and getting the most out of the hardware.

As we now live in a world where multi-core machines include the ones in our pockets, learning how to develop software in a less serial manner is important.
Moving away from objects messaging and getting responses immediately is part of the benefits available to the data-oriented programmer.
Programming, with a firm reliance on awareness of the data flow, sets you up to take the next step to GPGPU and other compute approaches.
This leads to handling workloads that bring game titles to life.
The need for data-oriented design will only grow.
It will grow because abstractions and serial thinking will be the bottleneck of your competitors, and those that embrace the data-oriented approach will thrive.

\subsection{It's All About The Data}

Data is all we have.
Data is what we need to transform in order to create a user experience.
Data is what we load when we open a document.
Data is the graphics on the screen, the pulses from the buttons on your gamepad, the cause of your speakers producing waves in the air, the method by which you level up and how the bad guy knew where you were so as to shoot at you.
Data is how long the dynamite took to explode and how many rings you dropped when you fell on spikes.
It is the current position and velocity of every particle in the beautiful scene that ended the game which was loaded off the disc and into your life via transformations by machinery driven by decoded instructions themselves ordered by assemblers instructed by compilers fed with source-code.

No application is anything without its data.
Adobe Photoshop without the images is nothing.
It's nothing without the brushes, the layers, the pen pressure.
Microsoft Word is nothing without the characters, the fonts, the page breaks.
FL Studio is worthless without the events.
Visual Studio is nothing without source.
All the applications that have ever been written, have been written to output data based on some input data.
The form of that data can be extremely complex, or so simple it requires no documentation at all, but all applications produce and need data.
If they don't need recognizable data, then they are toys or tech demos at best.

Instructions are data too.
Instructions take up memory, use up bandwidth, and can be transformed, loaded, saved and constructed.
It's natural for a developer to not think of instructions as being data, but there is very little differentiating them on older, less protective hardware.
Even though memory set aside for executables is protected from harm and modification on most contemporary hardware, this relatively new invention is still merely an invention, and the modified Harvard architecture relies on the same memory data as it does for instructions.
Instructions are therefore still data, and they are what we transform too.
We take instructions and turn them into actions.
The number, size, and frequency of them is something that matters.
The idea that we control over which instructions we use to solve problems leads us to optimizations.
Applying our knowledge of what the data is allows us to make decisions and which can be replaced with equivalent but less costly alternatives.

This forms the basis of the argument for a data-oriented approach to development, but leaves out one major element.
All this data and the transforming data, from strings, to images, to instructions, they all have to run on something.
Sometimes that thing is quite abstract, such as virtual machine running on unknown hardware.
Sometimes that thing is concrete, such as knowing which specific CPU and GPU you have, and the memory capacity and bandwidth you have available.
But in all cases, the data is not just data, but data that exists on some hardware somewhere, and it has to be transformed at the same hardware.
In essence, data-oriented design is the practice of designing software by developing transformation for well-formed data where the criteria for well-formed is guarded by the target hardware and the patterns and types of transformation that need to operate on it.
Sometimes the data isn't well defined, and sometimes the hardware is equally evasive, but in most cases a good background of hardware appreciation can help out almost every software project.

\subsection{Data Is Not The Problem Domain}

The first principle : Data is not the problem domain.

For some, it would seem that data-oriented design is the antithesis of most other programming paradigms because data-oriented design is a technique that does not readily allow the problem domain to enter into the software as written in source.
It does not promote the concept of an object as a mapping to the context of the user in any way, as data is intentionally and consistently without meaning.
Abstraction heavy paradigms try to pretend the computer and its data do not exist at every turn, abstracting away the idea that they are bytes, or CPU pipelines, or other hardware features, and instead bringing the model of the problem into the program.
They regularly bring either the model of the view into the code, or the model of the world as a context for the problem.
That is, either structure the code attrivutes of the expected solution, or they structure the code around the description of the problem domain.

Meaning can be applied to data to create information.
Meaning is not inherent in data.
When you say 4, it means very little, but say 4 miles, or 4 eggs, it means something.
When you have a list of positions in a game, they mean very little without context. Object-oriented design would likely have the positions as part of an object, and by the class name and neighbouring data (also named) you can get an idea of what thata data means.
Without the connected named contextualising data, the positions could be interpreted in a number of different ways, the data could be interpreted in a number of different ways, and though putting the numbers in context is good in some sense, it also blocks thinking about the positions as just sets of three numbers, which can be important for thinking of solutions to the real problems the programmers are trying to solve.

For an example of what can happen when you put data so deep inside an object that you forget its impact, consider the numerous games released, and in production, where a 2D or 3D grid system could have been used for the data layout, but for unknown reasons the developers kept with the object paradigm for each entity on the map.
This isn't a singular event, and real shipping games have seen this object-centric approach commit crimes against the hardware by having hundreds of objects placed in WorldSpace at grid coordinates at grid coordinates, rather than actually being driven by grid.
It's possible that programmers look at a grid, see the number of elements required to fulfil the request, and are hesitant to the idea of allocating it in a single lump of memory.
Consider a simple 256 by 256 tilemap requiring 65,536 tiles.
An object-oriented programmer may think about those sixty-five thousand objects as being quite expensive.
It might make more sense for them to allocate the objects for the tiles only when necessary, even to the point where there are literally 65, 0000 tiles created by hand in editor, but because they were placed by hand, their necessity has been established, and they are now something to be handled, rather than something potentially worrying.

Not only is this pervasive lack of an underlying form a poor way to handle rendering and simple element placement, but it leads to much higher complexity when interpreting locality of elements.
Gaining access to elements on a grid-free representations often requires jumping through hoops such as having neighbour links (which need to be kept up to date), running through the entire list of elements (inherently costly) or references to an auxillary augmented grid objects or spatial mapping connecting to the objects which are otherwise free to move, but won't, due to the design of the game.
This fake form of freedom introduced by the grid-free design presents issues with understanding the data, and has been the cause of some significant performance penalties in some titles.
Thus also causing significant waste of programmer mental resources in all.

Other than not having  grids where they make sense, many modern games also seem to carry instances for each and every item in the game.
An instance for each rather than a variable storing the number of items.
For some games this is an optimization, as creation and destruction of objects is a costly acitivty, but the trend is worrying, as these ways of stroing information about the world make the world impenetrable to simple interogation.

Many games seem to try to keep everything about the player in the player class.

\subsection{Data And Statistics}
\subsection{Data Can Change}
\subsection{How Is Data Formed?}
\subsection{What Can Provide A Computational Framework For Such Complex Data}
\subsection{Conclusions And Takeaways}
\section{Relational Databases}
\subsection{Complex State}
\subsection{Complex State}
\subsection{What Can Provide A Computational Framework For Complex Data}
\subsection{Normalising Your Data}
\subsection{Normalisation}
\subsubsection{Primary Keys}
\subsubsection{1st Normal Form}
\subsubsection{2nd Normal Form}
\subsubsection{3rd Normal Form}
\subsubsection{Boyce-Cold Normal Form}
\subsubsection{Domain Key/Knowledge}
\subsubsection{Reflections}
\subsection{Operations}
\subsection{Summing Up}
\subsection{Stream Processing}
\subsection{Why Does Database Technology Matter?}
\section{Existential Processing}
\subsection{Complexity}
\subsection{Debugging}
\subsection{Why Use An If}

\end{document}
