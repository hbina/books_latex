\documentclass[a4paper, 14pt]{extarticle}
\usepackage[utf8]{inputenc}

\title{Notes From OpenGL Redbook}
\author{Hanif Bin Ariffin}

\begin{document}

\maketitle
\tableofcontents

\newpage
\section{Chapter 1 : Introduction to OpenGL}

\subsection{What Is OpenGL}

This chapter describes the purpose of OpenGL, what it can and cannot do in creating computer-generated graphics.
In particular, OpenGL's purpose is very specific in that it does not provide any APIs for creating windows, what type of representation you have to use for models and many other functions one might associate with making a program.

The major operations that an OpenGL application would perform is the following:

\begin{itemize}
    \item Specify the data for constructing shapres from OpenGL's geometric primitives
    \item Execute various shaders to perform calculations on the input primitives to determine their position,color, and other rendering attributes.
    \item Finally, execute a fragment shader for each of the fragments generated by rasterization, which will determine the fragment's final color and position.
    \item Possibly perform additional per-fragment operations such as determining if the object that the fragment was generated from is visible, or blending the fragment's color with the current color in that screen location.
\end{itemize}

\subsection{First Look at an OpenGL Program}

A concept that is essential to using OpenGL is shaders, which could be think of as a basic verison of a C program that compiles to a something that is can be understood by GPUs.

In OpenGL, there are 4 shader stages that you can use.
The most common are vertex shaders (which process vertex data) and fragment shaders (which operate on the fragments generated by the rasterizer).
Both vertex and fragment shders are required in every OpenGL program!

The final generated image consists of pixels drawn on the screen;
a pixel is the smallest visible element on your display.
The pixels in your system are stored in a framebuffer, which is a chunk of memory that the graphics hardware manages, and feeds to your display device.

At some point, we have to do something that is called \textit{shader plumbing} where we associate the data in your application with variables in \textit{shader programs}.
This is discussed in Chapter 2.

\subsection{OpenGL Syntax}

This chapter talks about the common naming conventions used by OpenGL.
It also talks a lot about the integral types used by OpenGL.
I wonder how important this actually is?
Have anyone broken ports because the types mismatched?

\newpage
\section{Chapter 2 : Shader Fundamentals}

This chapter talks about:

\begin{itemize}
    \item
          Identify the various types of shaders that OpenGL uses to create images.

    \item
          Construct and compile shaders using the OpenGL Shading Language.

    \item
          Pass data into shaders using a variety of mechanisms available in OpenGL.

    \item
          Employ advanced GLSL shading capabilities to make shaders more reusable.

\end{itemize}

\subsection{Shaders and OpenGL}

Turns out shader is pretty much mandatory for any OpenGL applications that want to do anything besides clearing windows.
Funnily enough, it was originally only optional but over time, it replaces the old technique of \textit{fixed-function pipeline}.

In a way, it is very similar to C.

\subsection{OpenGL's Programmable Pipeline}

As of version 4.3, OpenGL provides 4 processing stagesm plus an unrelated compute stage:

\begin{itemize}
    \item
          The \textbf{vertex shading stage} receives the vertex data that you specified in your vertex-buffer objects, processing each vertex separately.
          This stage is mandatory for all OpenGL programs and must have a shader bound to it.
          We describe vertex shading operation in Chapter 3, ``Drawing with OpenGL''.
    \item
          The \textbf{tessellation shading stage} is an optional stage that generates additional geometry within the OpenGL pipeline, as compared to having the application specify each geometric primitive explicitly.
          This stage, if activated, receives the output of the vertex shading stage, and does further processing of the received vertices.
          We describe the tessellation shading stage in Chapter 9, ``Tessellation Shaders''.
    \item
          The \textbf{geometry shading stage} is another optional stage that can modify entire geometric primitives within the OpenGL pipeline.
          This stage operates on individual geometric primitives allowing each to be modified.
          In this stage, you might generate more geometry from the input primitive, change the type of geometric primitive (e.g., converting triangles to lines), or discarding the geometry altogether.
          If activated, geometry shading receives its input either after vertex shading has completed processing the vertices of a geometric primitive, or from the primitives generated from the tessellation shading stage, if it's been enabled.
          The geometry shading stage is described in Chapter 10, ``Geometry Shaders''.
    \item
          Finally, the last part of the OpenGL shading pipeline is the \textbf{fragment shading stage}.
          This stage processes the individual fragments (or samples, if sample-shading mode is enabled) generated by OpenGL's rasterizer, and also must have a shader bound to it.
          In this stage, a fragment's color and depth values are computed, and then sent for further OpenGL's processing in the fragment-testing and blending parts of the pipeline.
          Fragment shading operation is discussed in many sections of the text.
    \item
          The \textbf{compute shading stage} is not part of the graphical pipeline as the stages above, but rather stands on its own as the only stage in a program.
          A compute shader processes generic work items, driven by an application-chosen range, rather than by graphical inputs like vertices and fragments.
          Compute shaders can process buffers created and consumed by other shader programs in your application.
          This includes framebuffer post-processing effects, or really anything you want.
          Compute shaders are described in Chapter 12, ``Compute Shaders''.

\end{itemize}

\subsection{An Overview of the OpenGL Shading Language}



\end{document}
