\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={7in, 10in}]{geometry}
\usepackage{listings}
\usepackage{hyperref}
% Table stuff
\usepackage{tabularx,ragged2e,booktabs,caption}
\newcolumntype{C}[1]{>{\Centering}m{#1}}
\renewcommand\tabularxcolumn[1]{C{#1}}
% Extension for subsubsub...section of depth>3
\usepackage{titlesec}

\titleclass{\subsubsubsection}{straight}[\subsection]

\newcounter{subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection.\arabic{subsubsubsection}}
\renewcommand\theparagraph{\thesubsubsubsection.\arabic{paragraph}} % optional; useful if paragraphs are to be numbered

\titleformat{\subsubsubsection}
  {\normalfont\normalsize\bfseries}{\thesubsubsubsection}{1em}{}
\titlespacing*{\subsubsubsection}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{5}{\z@}%
  {3.25ex \@plus1ex \@minus.2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{6}{\parindent}%
  {3.25ex \@plus1ex \@minus .2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\def\toclevel@subsubsubsection{4}
\def\toclevel@paragraph{5}
\def\toclevel@paragraph{6}
\def\l@subsubsubsection{\@dottedtocline{4}{7em}{4em}}
\def\l@paragraph{\@dottedtocline{5}{10em}{5em}}
\def\l@subparagraph{\@dottedtocline{6}{14em}{6em}}
\makeatother

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\title{Notes From OpenGL Redbook}
\author{Hanif Bin Ariffin}

\begin{document}

\maketitle
\tableofcontents

\newpage
\section{Chapter 1 : Introduction to OpenGL}

\subsection{What Is OpenGL}

This chapter describes the purpose of OpenGL, what it can and cannot do in creating computer-generated graphics.
OpenGL's purpose is very specific in that it does not provide any APIs for creating windows, what type of representation you have to use for models and many other functions one might associate with making a program.

The major operations that an OpenGL application would perform is the following:

\begin{itemize}
      \item Specify the data for constructing shapres from OpenGL's geometric primitives
      \item Execute various shaders to perform calculations on the input primitives to determine their position,color, and other rendering attributes.
      \item Finally, execute a fragment shader for each of the fragments generated by rasterization, which will determine the fragment's final color and position.
      \item Possibly perform additional per-fragment operations such as determining if the object that the fragment was generated from is visible, or blending the fragment's color with the current color in that screen location.
\end{itemize}

\subsection{First Look at an OpenGL Program}

A concept that is essential to using OpenGL is shaders, which could be think of as a basic verison of a C program that compiles to a something that is can be understood by GPUs.

In OpenGL, there are 4 shader stages that you can use.
The most common are vertex shaders (which process vertex data) and fragment shaders (which operate on the fragments generated by the rasterizer).
Both vertex and fragment shders are required in every OpenGL program!

The final generated image consists of pixels drawn on the screen;
a pixel is the smallest visible element on your display.
The pixels in your system are stored in a framebuffer, which is a chunk of memory that the graphics hardware manages, and feeds to your display device.

At some point, we have to do something that is called \textit{shader plumbing} where we associate the data in your application with variables in \textit{shader programs}.
This is discussed in Chapter 2.

\subsection{OpenGL Syntax}

This chapter talks about the common naming conventions used by OpenGL.
It also talks a lot about the integral types used by OpenGL.
I wonder how important this actually is?
Have anyone broken ports because the types mismatched?

\newpage
\section{Chapter 2 : Shader Fundamentals}

This chapter talks about:

\begin{itemize}
      \item
            Identify the various types of shaders that OpenGL uses to create images.

      \item
            Construct and compile shaders using the OpenGL Shading Language.

      \item
            Pass data into shaders using a variety of mechanisms available in OpenGL.

      \item
            Employ advanced GLSL shading capabilities to make shaders more reusable.

\end{itemize}

\subsection{Shaders and OpenGL}

Turns out shader is pretty much mandatory for any OpenGL applications that want to do anything besides clearing windows.
Funnily enough, it was originally only optional but over time, it replaces the old technique of \textit{fixed-function pipeline}.

In a way, it is very similar to C.

\subsection{OpenGL's Programmable Pipeline}

As of version 4.3, OpenGL provides 4 processing stagesm plus an unrelated compute stage:

\begin{itemize}

      \item
            The \textbf{vertex shading stage} receives the vertex data that you specified in your vertex-buffer objects, processing each vertex separately.
            This stage is mandatory for all OpenGL programs and must have a shader bound to it.
            We describe vertex shading operation in Chapter 3, ``Drawing with OpenGL''.
      \item
            The \textbf{tessellation shading stage} is an optional stage that generates additional geometry within the OpenGL pipeline, as compared to having the application specify each geometric primitive explicitly.
            This stage, if activated, receives the output of the vertex shading stage, and does further processing of the received vertices.
            We describe the tessellation shading stage in Chapter 9, ``Tessellation Shaders''.
      \item
            The \textbf{geometry shading stage} is another optional stage that can modify entire geometric primitives within the OpenGL pipeline.
            This stage operates on individual geometric primitives allowing each to be modified.
            In this stage, you might generate more geometry from the input primitive, change the type of geometric primitive (e.g., converting triangles to lines), or discarding the geometry altogether.
            If activated, geometry shading receives its input either after vertex shading has completed processing the vertices of a geometric primitive, or from the primitives generated from the tessellation shading stage, if it's been enabled.
            The geometry shading stage is described in Chapter 10, ``Geometry Shaders''.
      \item
            Finally, the last part of the OpenGL shading pipeline is the \textbf{fragment shading stage}.
            This stage processes the individual fragments (or samples, if sample-shading mode is enabled) generated by OpenGL's rasterizer, and also must have a shader bound to it.
            In this stage, a fragment's color and depth values are computed, and then sent for further OpenGL's processing in the fragment-testing and blending parts of the pipeline.
            Fragment shading operation is discussed in many sections of the text.
      \item
            The \textbf{compute shading stage} is not part of the graphical pipeline as the stages above, but rather stands on its own as the only stage in a program.
            A compute shader processes generic work items, driven by an application-chosen range, rather than by graphical inputs like vertices and fragments.
            Compute shaders can process buffers created and consumed by other shader programs in your application.
            This includes framebuffer post-processing effects, or really anything you want.
            Compute shaders are described in Chapter 12, ``Compute Shaders''.

\end{itemize}

\subsection{An Overview of the OpenGL Shading Language}

GLSL is extremely similar to C with a little bit of C++.

\subsubsection{Creating Shaders with GLSL}

\subsubsubsection{The Starting Point}

Just like any C/C++ programs, a shader program begins its execution in the function \verb|void main()|.
Unlike C, GLSL's \verb|main()| does not accept any arguments nor does it return any value.

\subsubsubsection{Declaring Variables}

GLSL provides several basic data types that can be used to define a variable's type.
The rules of allowed variable names are similar to C/C++ with the additional rule that variable names cannot contain consecutive underscores (\verb|_|).
Names with consecutive underscores are reserved in GLSL.

\begin{minipage}{\textwidth}
\centering
\captionof{table}{Basic Data Types in GLSL}
\begin{tabular}{ c c }\toprule[1.5pt]
\bf Type & \bf Description\\\midrule
\verb|float| & IEEE 32-bit floating-point value \\
\verb|double| & IEEE 64-bit floating-point value \\
\verb|int| & signed two's complement 32-bit integer value \\
\verb|uint| & unsigned 32-bit integer value \\
\verb|bool| & Boolean value \\
\bottomrule[1.25pt]
\end {tabular}\par
\bigskip

\end{minipage}

These types (and later, aggregate types composed of these) are all transparent.
Their internal form is exposed and the shader code gets to assume what they look like internally.
In other words, they are a \verb|struct| instead of a \verb|class|.

An additional set of types --- the opaque types --- do not have their internal form exposed.
These include sampler types, image types and atomic counter types.
They declare variables used as opaque handles for accessing texture maps, images and atomic counters as described in Chapter 4.

The various types of samplers and their uses are discussed in Chapter 6.

// TODO :: Take a look at this \href{https://tex.stackexchange.com/questions/60209/how-to-add-an-extra-level-of-sections-with-headings-below-subsubsection}{page} for a fix to the current problem.

\subsubsubsection{Variable Scoping}

\subsubsubsection{Variable Initialization}

\subsubsubsection{Constructor}

\subsubsubsection{Aggregate Types}

\subsubsubsection{Accessing Elements in Vectors and Matrices}

\subsubsubsection{Structures}

\subsubsubsection{Arrays}

\subsubsubsection{Storage Qualifiers}

// TODO :: This is actually quite important, try to write it down some time.

\subsubsubsection{Statements}

\paragraph{Arithmetic Operations}
\paragraph{Overloaded Operations}
\paragraph{Flow Control}
\paragraph{Looping Constructs}
\paragraph{Flow-Control Statements}
\paragraph{Declarations}
\paragraph{Parameter Qualifiers}

This is pretty interesting. Look it up.

\paragraph{Computational Invariance}

This is quite important if you want to do compute shader.

\begin{itemize}

      \item
            The \verb|invariant| Qualifier
      \item
            The \verb|precise| Qualifier

\end{itemize}

\subsubsection{Shader Preprocessor}

The first step in compiling a shader is the parsing the preprocessor.

\subsubsubsection{Preprocessor Directives}

Very similar to C/C++ preprocessor with the notable exclusion of \verb|include|.

// TODO :: Table

\subsubsubsection{Macros}
\subsubsubsection{Preprocessor Conditionals}

\subsubsection{Compiler Control}

\subsubsubsection{Optimization Compiler Option}
\subsubsubsection{Debug Compiler Option}

\subsubsection{Global Shader-Compilation Option}

\subsubsubsection{Extension Processing in Shaders}

// TODO :: Table

\subsubsection{Interface Blocks}

// TODO :: This is actually quite important if we are going to do anything complex.
Also helps with designing our AkarinShader class.

\subsubsubsection{Uniform Blocks}
\subsubsubsection{Specifying Uniform Blocks in Shader}

// TODO :: Layout qualifiers for Uniform

\subsubsubsection{Accessing Uniform Variables Declared in a Uniform Block}

\subsubsection{Accessing Uniform Blocks from Your Application}

Lots of OpenGL's documentation here.

Also example code.

\subsubsection{Buffer Blocks}

From the application's perspective, this is more like the \textit{shader storage buffer objects}.
This is very similar to uniform blocks.
There are 2 differences however:

\begin{enumerate}

      \item
            Shaders can write to them.
            Thus, any other shader invocations or the application will see the change.
      \item
            Their size can be established just before rendering, rather than at compile time or link time.

            \begin{lstlisting}
                  buffer BufferObject {
                        int mode;
                        vec4 points[];
                  };
            \end{lstlisting}

            In the above listings, we never set the size of the array \verb|points|.
            However, we can dynamically resize the array before any rendering calls.
            Don't fret!
            We can obtain its size using \verb|length()| function.

            This is especially useful in compute shaders.

\end{enumerate}

\subsubsection{In/Out Blocks}

Shader variables can move between stages.
These can be organized into interface blocks.
These local groupings makes it easier to visuall verify that the interfaces matches between stages.

For instance, for lighting purposes we could have our vertex shader output the following block:

\begin{lstlisting}
      out Lighting {
            vec3 normal;
            vec2 bumpCoord;
      }
\end{lstlisting}

Then the other stage receiving this output must have the matching:

\begin{lstlisting}
      in Lighting {
            vec3 normal;
            vec2 bumpCoord;
      }
\end{lstlisting}

GLSL's defined in/out variables are also organized into blocks.
For example, \verb|gl_perVertex| contains the built-in variable \verb|gl_Position| among others.

\subsubsection{Compiling Shaders}

This step of the process is similar to compiler-based languages like C.
We have a code, we let a compiler analyze, and if there are no errors, generate an object file for us.
Next, you link multiple object files to generate an executable.

I suppose the difference here is that everything is opaque.
One only receives the handle for the object files and the executable.

\end{document}
